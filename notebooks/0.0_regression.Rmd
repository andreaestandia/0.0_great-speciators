---
title: "0.0_regression.Rmd"
author: "Andrea Estandia<br>"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  github_document:
  toc: true
toc_depth: 4
editor_options:
  chunk_output_type: console
---
  <br>
  
```{r setup, echo=FALSE}
# Knitr settings: 
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
options(scipen = 999)
```

```{r, echo=FALSE}
source("./src/0.0_great-speciators_source.R")
```

```{r}
total_melanesia <- read_csv(file.path(data_path, "dfs/total_melanesia.csv"))

total_melanesia_model <- total_melanesia %>% filter(nsubsp/npoly<=1) %>% mutate(nsubsp=ifelse(nsubsp!=0, nsubsp, 1))

total_melanesia_model$altitude_range <- as.numeric(total_melanesia_model$altitude_range)

total_melanesia_model2 <- total_melanesia_model %>% mutate(rel_island_size = log(area)/log(npoly)) %>% mutate(rel_island_size=na_if(rel_island_size, Inf)) %>% distinct(species_name, .keep_all = TRUE) %>% drop_na(rel_island_size,nsubsp,npoly)
total_melanesia_model2 <- total_melanesia_model2 %>%  mutate(rel_island_size=na_if(rel_island_size, -Inf))
total_melanesia_model2$rel_island_size <- stdize(total_melanesia_model2$rel_island_size, na.rm=TRUE)

######
tree_vig <- read.tree(file.path(data_path, "/raw/bamm/birds_hackett.tre"))
cons_vig = ape::consensus(tree_vig, p=0.5) # To get the majority-rule consensus tree, use p = 0.5
######

df_mel = total_melanesia_model2 %>% distinct(species_name, .keep_all = TRUE) %>% 
  filter(tree_name %in% tree_vig$tip.label) %>%  mutate(failures=npoly-nsubsp)

df_mel_2 <- df_mel %>% mutate(log_median=log(median)) %>% mutate(log_max=log(max_dist_poly)) %>% mutate(log_area=log(area)) %>% drop_na(altitude_range) %>% mutate(altitude_range=na_if(altitude_range, -Inf)) %>% drop_na(altitude_range) %>% mutate(rel_median_npoly=log(median)/log(npoly)) %>%  mutate(rel_median_npoly=na_if(rel_median_npoly, -Inf)) %>% drop_na(rel_median_npoly)

list_var <- c(
  "hwi",
  "PC1",
  "precip_range",
  "altitude_range",
  "temperature_range",
  "log_max",
  "log_median",
  "netdiv"
)

lst=NULL
for (variable in list_var) {
  lst[[variable]] <- df_mel_2 %>% 
    dplyr::select(variable) %>%  
    stdize(.,na.rm=TRUE)
}

standarised <- do.call(cbind, unname(lst))
colnames(standarised) <- paste0("norm_", colnames(standarised))

df_mel_final <- cbind(df_mel_2, standarised)

phylo_mel <- keep.tip(tree_vig,df_mel_final$tree_name)

phylo_mel2 = compute.brlen(phylo_mel) # computes branch lengths, needed for next steps
mel_phylo <- vcv.phylo(phylo_mel2, cor = T)

mod_mel <- pglmm(cbind(nsubsp,failures)~norm_hwi*norm_PC1+norm_precip_range*norm_altitude_range*norm_temperature_range+norm_log_max+norm_log_median+norm_netdiv+Realm+diet+habitat+migratory_status_3+(1|tree_name__), data=df_mel_final, cov_ranef = list(tree_name = mel_phylo), family="binomial", bayes = TRUE, prior="pc.prior.auto")

plot_bayes(mod_mel)

mod_mel_freq <- pglmm(cbind(nsubsp,failures)~norm_hwi*norm_PC1+norm_precip_range*norm_altitude_range*norm_temperature_range+norm_log_max+norm_log_median+norm_netdiv+Realm+diet+habitat+migratory_status_3+(1|tree_name__), data=df_mel_final, cov_ranef = list(tree_name = mel_phylo), family="binomial", bayes = FALSE)
DHARMa::simulateResiduals(mod_mel)

communityPGLMM.plot.re(x=mod_mel, sp.var="sp.col.name")

predict <- pglmm_predicted_values(mod,
                                      type = c("link", "response")
                                      )

fitted <- fitted(mod,
                     type = c("link", "response")
                                      )
predicted_values <- cbind(predict, mod$data)

library(scales)
#create exp(x)-1 transformation, the inverse of log(1+p)
expm1_trans <-  function() trans_new("expm1", "expm1", "log1p")

list_vars <- c("norm_hwi",
    "norm_PC1",
    "norm_precip_range",
    "norm_altitude_range",
    "norm_temperature_range",
    "norm_log_max",
    "norm_log_median",
    "norm_netdiv",
    "Realm",
    "diet",
    "migratory_status_3",
    "habitat")

plot_habitat <- predicted_values %>%
  drop_na(
    list_vars
  ) %>%
  ggplot(aes(y = Y_hat, x = habitat)) +
  geom_jitter(col = "#886f8f", alpha = 0.4) +
  geom_smooth(
    method = "glm",
    method.args = list(family = binomial),
    color = "black"
  ) +
  theme(
    plot.title = element_text(family = "Ubuntu", size = text_size),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.x = element_text(
      size = text_size,
      vjust = 0.9,
      hjust = 1,
      angle = 45,
      face = "italic",
      family = "Ubuntu"
    ),
    axis.text.y = element_text(family = "Ubuntu"),
    axis.title.x = element_text(family = "Ubuntu"),
    axis.title.y = element_text(family = "Ubuntu"),
    axis.ticks.y = element_blank()
  ) + labs(y = "Number of subspecies given opportunity\n", x="\nHabitat")
 
plot_total <- plot_pc1+plot_hwi+plot_precip_range+plot_temp_range+plot_altitude+plot_max+plot_median+plot_div+plot_habitat+plot_diet+plot_realm+plot_migr
  

df_world_final %>%
  distinct(species_name, .keep_all = T) %>% 
  ggplot(aes(y = stdize(nsubsp/npoly,na.rm=T), x = altitude_range)) +
  geom_jitter(col = "#886f8f", alpha = 0.4)+geom_smooth(
    method = "glm",
    method.args = list(family = binomial),
    color = "black"
  )
df_world_final %>%
  distinct(species_name, .keep_all = T) %>% 
  ggplot(aes(y = norm_precip_range, x = norm_temperature_range)) +
  geom_jitter(col = "#886f8f", alpha = 0.4)+geom_smooth(
    method = "glm",
    method.args = list(family = binomial),
    color = "black"
  )

##########################
total_world <- read_csv(file.path(data_path, "dfs/worldd.csv"))

total_world_model <- total_world %>% filter(nsubsp/npoly<=1) %>% mutate(nsubsp=ifelse(nsubsp!=0, nsubsp, 1)) 

total_world_model$altitude_range <- as.numeric(total_world_model$altitude_range)

total_world_model2 <- total_world_model %>% mutate(rel_island_size = log(area)/log(npoly)) %>% mutate(rel_island_size=na_if(rel_island_size, Inf)) %>% distinct(species_name, .keep_all = TRUE) %>% drop_na(rel_island_size,nsubsp,npoly)
total_world_model2 <- total_world_model2 %>%  mutate(rel_island_size=na_if(rel_island_size, -Inf))
total_world_model2$rel_island_size <- stdize(total_world_model2$rel_island_size, na.rm=TRUE)

df_world = total_world_model2 %>% distinct(species_name, .keep_all = TRUE) %>% 
  filter(tree_name %in% tree_vig$tip.label) %>%  mutate(failures=npoly-nsubsp)

df_world_2 <- df_world %>% mutate(log_median=log(median)) %>% mutate(log_max=log(max_dist_poly)) %>% mutate(log_area=log(area)) %>% drop_na(altitude_range) %>% mutate(altitude_range=na_if(altitude_range, -Inf)) %>% drop_na(altitude_range) %>% mutate(rel_median_npoly=log(median)/log(npoly)) %>%  mutate(rel_median_npoly=na_if(rel_median_npoly, -Inf)) %>% drop_na(rel_median_npoly)

list_var <- c(
  "hwi",
  "PC1",
  "precip_range",
  "altitude_range",
  "temperature_range",
  "log_max",
  "log_median",
  "netdiv"
)

lst=NULL
for (variable in list_var) {
  lst[[variable]] <- df_world_2 %>% 
    dplyr::select(variable) %>%  
    stdize(.,na.rm=TRUE)
}

standarised <- do.call(cbind, unname(lst))
colnames(standarised) <- paste0("norm_", colnames(standarised))

df_world_final <- cbind(df_world_2, standarised)

phylo_world <- keep.tip(tree_vig,df_world_final$tree_name)

phylo_world2 = compute.brlen(phylo_world) # computes branch lengths, needed for next steps
world_phylo <- vcv.phylo(phylo_world2, cor = T)

mod <- pglmm(cbind(nsubsp,failures)~norm_hwi*norm_PC1+norm_precip_range*norm_altitude_range+norm_altitude_range*norm_temperature_range+norm_temperature_range*norm_precip_range+norm_log_max+norm_log_median+norm_netdiv+Realm+diet+habitat+migratory_status_3+(1|tree_name__), data=df_world_final, cov_ranef = list(tree_name = world_phylo), family="binomial", bayes = TRUE, prior="pc.prior.auto")

null <- pglmm(cbind(nsubsp,failures)~1+(1|tree_name__), data=df_world_final, cov_ranef = list(tree_name = world_phylo), family="binomial", bayes = TRUE, prior="pc.prior.auto")

deviance <- 2*(mod$logLik - null$logLik)
pchisq(deviance, df=1, lower.tail=F)
LRT.b1 <- c(dev = deviance, p.value=pchisq(deviance, df=1, lower.tail=F))

test_nested <- phyr::pglmm_profile_LRT(mod, re.number = 6)
LRTs <- sapply(1:6, FUN = function(x) 
  phyr::pglmm_profile_LRT(mod, re.number = x))
colnames(LRTs) <- names(mod$ss)
t(LRTs)

plot_bayes(mod, predicted = TRUE)
rr2::R2(mod)

mod_freq <- pglmm(cbind(nsubsp,failures)~hwi*PC1+precip_range*altitude_range+altitude_range*temperature_range+temperature_range*precip_range+log_max+log_median+netdiv+Realm+latitude+diet+habitat+migratory_status_3+(1|tree_name__), data=g2, cov_ranef = list(tree_name = vig_phylo), family="binomial", bayes = FALSE, prior="pc.prior.auto")
```

```{r}
mod <- brm(nsubsp|trials(npoly)~hwi*PC1+Beak_PC1+log_max+log_median+div_rate,
    data=g2,
    family=zero_inflated_binomial("probit"),
    chains = 2, iter = 4000,
    control = list(adapt_delta = 0.95))

mod_world_brms <- brm(nsubsp|trials(npoly)~norm_hwi*norm_PC1+norm_precip_range*norm_altitude_range+norm_altitude_range*norm_temperature_range+norm_temperature_range*norm_precip_range+norm_log_max+norm_log_median+norm_netdiv+Realm+diet+habitat+migratory_status_3+(1|gr(tree_name, cov = world_phylo)),
    data=df_world_final,
    data2 = list(world_phylo = world_phylo),
    chains = 2, iter = 4000,
    inits = "0",
    control = list(adapt_delta = 0.95),
    family=zero_inflated_binomial("probit"))
    
plot(mod2, N = 2, ask = FALSE)
plot(conditional_effects(mod, points=TRUE, method="predict", conditions = data.frame(npoly=40)))
pp_check(mod2)

plot(conditional_effects(fit2, conditions=data.frame(npoly=50)), points=TRUE)

n <- sample(1:10, 100, TRUE) # number of trials
success <- rbinom(100, size = n, prob = 0.4)
x <- rnorm(100)
data2 <- data.frame(n, success, x)

fit2 <- brm(nsubsp | trials(npoly) ~ hwi, data = g2,
family = binomial("probit"))

g2 %>% ggplot(aes(y=nsubsp,x=npoly))+geom_point()+geom_smooth(method="lm")
```
